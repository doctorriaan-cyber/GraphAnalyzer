
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Graph Analyzer</title>
    <style>
        body, html {
            margin: 0;
            padding: 0;
            width: 100%;
            height: 100%;
            display: flex;
            justify-content: center;
            align-items: center;
            background-color: #f0f2f5;
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
            overflow: hidden;
        }
        .container {
            display: flex;
            flex-direction: column;
            align-items: center;
            width: 100%;
            padding: 1rem;
            box-sizing: border-box;
            max-height: 100vh;
            overflow-y: auto;
        }
        h1 {
            color: #333;
            font-size: 1.5rem;
            margin: 0 0 1rem 0;
            text-align: center;
        }
        .range-controls {
            display: flex;
            gap: 0.5rem;
            align-items: center;
            margin-bottom: 0.5rem;
            color: #555;
            font-size: 0.9rem;
        }
        .range-controls input {
            width: 60px;
            padding: 0.5rem;
            border: 1px solid #ccc;
            border-radius: 4px;
            font-size: 1rem;
            text-align: center;
        }
        #updateRangeBtn {
            margin-bottom: 1rem;
            background-color: #6c757d;
            color: white;
            padding: 0.5rem 1rem;
            font-size: 0.9rem;
        }
        #updateRangeBtn:hover {
            background-color: #5a6268;
        }
        .input-prompt {
            color: #666;
            font-size: 0.9rem;
            margin-bottom: 0.5rem;
            text-align: center;
        }
        .function-input-container {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            margin-bottom: 1rem;
            width: 90%;
            max-width: 380px;
        }
        .function-input-container label {
            font-family: 'SF Mono', 'Courier New', monospace;
            font-size: 1.1rem;
            color: #333;
        }
        .function-input-container input {
            flex-grow: 1;
            padding: 0.5rem;
            border: 1px solid #ccc;
            border-radius: 4px;
            font-size: 1rem;
            font-family: 'SF Mono', 'Courier New', monospace;
        }
        canvas {
            background-color: #ffffff;
            border: 2px solid #cccccc;
            border-radius: 8px;
            box-shadow: 0 4px 8px rgba(0,0,0,0.1);
            cursor: crosshair;
            touch-action: none;
        }
        .controls {
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            gap: 1rem;
            margin-top: 1rem;
        }
        button {
            padding: 0.75rem 1.5rem;
            font-size: 1rem;
            font-weight: 600;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            transition: background-color 0.2s ease, transform 0.1s ease;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            -webkit-tap-highlight-color: transparent;
        }
        button:active {
            transform: scale(0.98);
        }
        #analyzeBtn {
            background-color: #007bff;
            color: white;
        }
        #analyzeBtn:hover:not(:disabled) {
            background-color: #0056b3;
        }
        #analyzeBtn:disabled {
            background-color: #a0c7ff;
            cursor: not-allowed;
        }
        #drawFuncBtn {
            background-color: #28a745;
            color: white;
        }
        #drawFuncBtn:hover:not(:disabled) {
            background-color: #218838;
        }
        #drawFuncBtn:disabled {
            background-color: #94dcb0;
            cursor: not-allowed;
        }
        #clearBtn, #toggleDrawingBtn {
            background-color: #f1f3f5;
            color: #333;
            border: 1px solid #ddd;
        }
        #clearBtn:hover, #toggleDrawingBtn:hover {
            background-color: #e2e6ea;
        }
        .force-controls-container {
            margin-top: 1.5rem;
            width: 90%;
            max-width: 400px;
            text-align: center;
        }
        .force-controls-container h3 {
            margin: 0 0 0.5rem 0;
            font-size: 0.9rem;
            color: #555;
            font-weight: 600;
        }
        .force-controls {
            display: flex;
            flex-wrap: wrap;
            gap: 0.5rem;
            justify-content: center;
        }
        .force-btn {
            padding: 0.4rem 0.8rem;
            font-size: 0.85rem;
            font-weight: 500;
            background-color: #f8f9fa;
            color: #333;
            border: 1px solid #ddd;
            border-radius: 6px;
            box-shadow: none;
        }
        .force-btn.active {
            background-color: #007bff;
            color: white;
            border-color: #007bff;
            font-weight: 600;
        }
        #result-container {
            margin-top: 1rem;
            padding: 0.5rem 1rem;
            background-color: #ffffff;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.05);
            min-height: 50px;
            width: 90%;
            max-width: 380px;
            box-sizing: border-box;
            text-align: left;
        }
        #result {
            font-family: 'SF Mono', 'Courier New', monospace;
            font-size: 1rem;
            color: #333;
            word-break: break-all;
        }
        #result .placeholder {
            color: #999;
            font-style: italic;
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
            font-size: 1rem;
            display: block;
            text-align: center;
        }
        #result ol {
            padding-left: 25px;
            margin: 0.5rem 0;
        }
        #result li {
            margin-bottom: 0.5rem;
        }
        #result .color-swatch {
            display: inline-block;
            width: 12px;
            height: 12px;
            border-radius: 50%;
            margin-right: 8px;
            vertical-align: middle;
        }
        .hidden {
            display: none;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>Graph Analyzer</h1>
        <div class="range-controls">
            <label for="minRange">Min:</label>
            <input type="number" id="minRange" value="-8" step="1">
            <label for="maxRange">Max:</label>
            <input type="number" id="maxRange" value="8" step="1">
        </div>
        <button id="updateRangeBtn">Update Range</button>
        <p class="input-prompt">Either input a function or draw a graph to analyze</p>
        <div class="function-input-container">
            <label for="functionInput">f(x) =</label>
            <input type="text" id="functionInput" placeholder="e.g., sin(x) * 5">
        </div>
        <canvas id="drawCanvas"></canvas>
        <div class="controls">
            <button id="analyzeBtn">Analyze</button>
            <button id="drawFuncBtn" disabled>Draw Function</button>
            <button id="toggleDrawingBtn" class="hidden">Hide Drawing</button>
            <button id="clearBtn">Clear</button>
        </div>
        <div class="force-controls-container">
            <h3>Force type of graph</h3>
            <div class="force-controls">
                <button class="force-btn active" data-type="auto">Auto</button>
                <button class="force-btn" data-type="line">Line</button>
                <button class="force-btn" data-type="quadratic">Quadratic</button>
                <button class="force-btn" data-type="cubic">Cubic</button>
                <button class="force-btn" data-type="exponential">Exponential</button>
                <button class="force-btn" data-type="reciprocal">Reciprocal</button>
                <button class="force-btn" data-type="circle">Circle</button>
                <button class="force-btn" data-type="trigonometric">Trigonometry</button>
            </div>
        </div>
        <div id="result-container">
            <div id="result">
                <span class="placeholder">Draw a function and click "Analyze"</span>
            </div>
        </div>
    </div>

    <script type="module">
        document.addEventListener('DOMContentLoaded', () => {
            // DOM Elements
            const canvas = document.getElementById('drawCanvas');
            const analyzeBtn = document.getElementById('analyzeBtn');
            const clearBtn = document.getElementById('clearBtn');
            const drawFuncBtn = document.getElementById('drawFuncBtn');
            const toggleDrawingBtn = document.getElementById('toggleDrawingBtn');
            const resultEl = document.getElementById('result');
            const minRangeInput = document.getElementById('minRange');
            const maxRangeInput = document.getElementById('maxRange');
            const updateRangeBtn = document.getElementById('updateRangeBtn');
            const functionInput = document.getElementById('functionInput');
            const forceBtns = document.querySelectorAll('.force-btn');
            const ctx = canvas.getContext('2d');
            
            const container = document.querySelector('.container');
            const h1 = document.querySelector('h1');
            const rangeControls = document.querySelector('.range-controls');
            const controls = document.querySelector('.controls');
            const resultContainer = document.getElementById('result-container');
            const inputPrompt = document.querySelector('.input-prompt');
            const functionInputContainer = document.querySelector('.function-input-container');
            const forceControlsContainer = document.querySelector('.force-controls-container');

            if (!canvas || !ctx || !analyzeBtn || !clearBtn || !drawFuncBtn || !toggleDrawingBtn || !resultEl || !minRangeInput || !maxRangeInput || !updateRangeBtn || !functionInput || !container || !h1 || !rangeControls || !controls || !resultContainer || !inputPrompt || !functionInputContainer || !forceControlsContainer) {
                console.error('Essential DOM elements not found.');
                return;
            }
            
            const remToPx = (rem) => rem * parseFloat(getComputedStyle(document.documentElement).fontSize);
            
            const calculateCanvasSize = () => {
                 const verticalSpacing = 
                    remToPx(1) + remToPx(1) + remToPx(0.5) + remToPx(1) + remToPx(0.5) + 
                    remToPx(1) + remToPx(1.5) + remToPx(1) + remToPx(1); 
                const otherElementsHeight = h1.offsetHeight + rangeControls.offsetHeight + updateRangeBtn.offsetHeight + inputPrompt.offsetHeight +
                    functionInputContainer.offsetHeight + controls.offsetHeight + forceControlsContainer.offsetHeight + resultContainer.offsetHeight;
                const totalNonCanvasHeight = otherElementsHeight + verticalSpacing;
                const availableHeight = window.innerHeight - totalNonCanvasHeight;
                const availableWidth = container.clientWidth;
                return Math.max(150, Math.floor(Math.min(availableWidth, availableHeight)));
            }

            const baseSize = calculateCanvasSize();
            const dpr = window.devicePixelRatio || 1;
            canvas.width = baseSize * dpr;
            canvas.height = baseSize * dpr;
            canvas.style.width = `${baseSize}px`;
            canvas.style.height = `${baseSize}px`;
            ctx.scale(dpr, dpr);

            // App State
            let isDrawing = false;
            let lines = [];
            let analyzedFormulas = [];
            let formulasToDraw = [];
            let forceGraphType = 'auto';
            let isDrawingVisible = true;
            const plotColors = ['#007bff', '#28a745', '#dc3545', '#ffc107', '#17a2b8'];

            // --- Coordinate Conversion ---
            const getRange = () => {
                let min = parseFloat(minRangeInput.value) || -8, max = parseFloat(maxRangeInput.value) || 8;
                const limit = 30;
                min = Math.max(-limit, Math.min(limit, min)); max = Math.max(-limit, Math.min(limit, max));
                if (min >= max) max = min + 1;
                return { min, max };
            };
            const graphToCanvas = (gx, gy) => {
                const { min, max } = getRange(), range = max - min;
                const x = ((gx - min) / range) * baseSize, y = baseSize - (((gy - min) / range) * baseSize);
                return { x, y };
            };
            const canvasToGraph = (cx, cy) => {
                const { min, max } = getRange(), range = max - min;
                const gx = (cx / baseSize) * range + min, gy = ((baseSize - cy) / baseSize) * range + min;
                return { x: gx, y: gy };
            };

            // --- Drawing Functions ---
            const drawAxes = () => {
                const { min, max } = getRange();
                ctx.strokeStyle = '#cccccc'; ctx.lineWidth = 1; ctx.font = `${12}px Arial`;
                ctx.fillStyle = '#888888'; ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
                const origin = graphToCanvas(0, 0);
                ctx.beginPath(); ctx.moveTo(origin.x, 0); ctx.lineTo(origin.x, baseSize); ctx.stroke();
                ctx.beginPath(); ctx.moveTo(0, origin.y); ctx.lineTo(baseSize, origin.y); ctx.stroke();
                const tickCount = 5, range = max - min, step = range / tickCount;
                for (let i = 0; i <= tickCount; i++) {
                    const val = min + i * step, tickVal = parseFloat(val.toFixed(1));
                    const xTickPos = graphToCanvas(tickVal, 0);
                    ctx.fillText(tickVal.toString(), xTickPos.x, origin.y + 15);
                    if (tickVal !== 0) {
                        const yTickPos = graphToCanvas(0, tickVal);
                        ctx.textAlign = 'right'; ctx.fillText(tickVal.toString(), origin.x - 8, yTickPos.y);
                        ctx.textAlign = 'center';
                    }
                }
            };
            const drawUserPath = () => {
                 if (!isDrawingVisible) return;
                 ctx.strokeStyle = '#000000'; ctx.lineWidth = 2.5; ctx.lineCap = 'round'; ctx.lineJoin = 'round';
                lines.forEach(line => {
                    if (line.length < 2) return;
                    ctx.beginPath(); const startPoint = graphToCanvas(line[0].x, line[0].y); ctx.moveTo(startPoint.x, startPoint.y);
                    for (let i = 1; i < line.length; i++) { const point = graphToCanvas(line[i].x, line[i].y); ctx.lineTo(point.x, point.y); }
                    ctx.stroke();
                });
            };
            const sanitizeAndCreateFunction = (formula) => {
                 if (!formula) return null;
                let sanitizedFormula = formula.trim().replace(/^f\(x\)\s*=\s*/i, '').replace(/\^/g, '**');
                const mathKeywords = ['sin', 'cos', 'tan', 'sqrt', 'exp', 'log', 'abs', 'PI', 'E'];
                mathKeywords.forEach(keyword => {
                    const regex = new RegExp(`\\b${keyword}\\b`, 'gi');
                    const replacement = (keyword === 'PI' || keyword === 'E') ? `Math.${keyword.toUpperCase()}` : `Math.${keyword.toLowerCase()}`;
                    sanitizedFormula = sanitizedFormula.replace(regex, replacement);
                });
                sanitizedFormula = sanitizedFormula.replace(/(\d)([a-zA-Z(])/g, '$1*$2').replace(/(\))([a-zA-Z\d(])/g, '$1*$2').replace(/x\(/g, 'x*(');
                try { return new Function('x', `return ${sanitizedFormula}`); } catch (error) { console.error("Error creating function from formula:", error, sanitizedFormula); return null; }
            };
            const drawEllipseOnCanvas = (params, color) => {
                if (!params) return;
                const { h, k, a, b, angle } = params, centerCanvas = graphToCanvas(h, k), { min, max } = getRange(), range = max - min;
                const radiusXCanvas = (a / range) * baseSize, radiusYCanvas = (b / range) * baseSize;
                ctx.beginPath(); ctx.strokeStyle = color; ctx.lineWidth = 2;
                ctx.ellipse(centerCanvas.x, centerCanvas.y, radiusXCanvas, radiusYCanvas, -angle, 0, 2 * Math.PI); ctx.stroke();
            };
            const drawCircleOnCanvas = (params, color) => {
                 if (!params) return;
                 drawEllipseOnCanvas({ h: params.h, k: params.k, a: params.r, b: params.r, angle: 0 }, color);
            };
            const drawFormulaOnCanvas = (formula, color, domain) => {
                if (!formula) return;
                const func = sanitizeAndCreateFunction(formula); if (!func) return;
                try {
                    const { min: rangeMin, max: rangeMax } = getRange();
                    const startX = domain ? Math.max(domain.xMin, rangeMin) : rangeMin;
                    const endX = domain ? Math.min(domain.xMax, rangeMax) : rangeMax;

                    ctx.beginPath(); ctx.strokeStyle = color; ctx.lineWidth = 2;
                    let firstPoint = true; const steps = baseSize * 2;
                    for (let i = 0; i <= steps; i++) {
                        const gx = startX + (i / steps) * (endX - startX); let gy;
                        try { gy = func(gx); } catch(e) { firstPoint = true; continue; }
                        if (typeof gy !== 'number' || !isFinite(gy)) { firstPoint = true; continue; }
                        const {x, y} = graphToCanvas(gx, gy);
                        if (firstPoint) { ctx.moveTo(x, y); firstPoint = false; } else { ctx.lineTo(x, y); }
                    }
                    ctx.stroke();
                } catch (error) { console.error("Error drawing formula graph:", error, formula); }
            };
            const redrawScene = () => {
                ctx.clearRect(0, 0, baseSize, baseSize);
                drawAxes();
                drawUserPath();
                if (formulasToDraw && formulasToDraw.length > 0) {
                    formulasToDraw.forEach((formulaInfo, index) => {
                        const color = plotColors[index % plotColors.length];
                        if (formulaInfo.type === 'circle') drawCircleOnCanvas(formulaInfo.params, color);
                        else if (formulaInfo.type === 'ellipse') drawEllipseOnCanvas(formulaInfo.params, color);
                        else drawFormulaOnCanvas(formulaInfo.formula, color, formulaInfo.domain);
                    });
                }
            };
            const reset = () => {
                lines = []; analyzedFormulas = []; formulasToDraw = []; functionInput.value = '';
                minRangeInput.value = '-8'; maxRangeInput.value = '8';
                resultEl.innerHTML = `<span class="placeholder">Draw a function and click "Analyze"</span>`;
                analyzeBtn.disabled = false; analyzeBtn.textContent = "Analyze"; drawFuncBtn.disabled = true;
                forceGraphType = 'auto';
                isDrawingVisible = true;
                toggleDrawingBtn.classList.add('hidden');
                toggleDrawingBtn.textContent = 'Hide Drawing';
                forceBtns.forEach(btn => {
                    btn.classList.remove('active');
                    if (btn.dataset.type === 'auto') btn.classList.add('active');
                });
                redrawScene();
            };
            
            // --- Event Handlers & Analysis Logic ---
            const getCoordinates = (event) => {
                const rect = canvas.getBoundingClientRect();
                if (event instanceof TouchEvent && event.touches.length > 0) return { x: event.touches[0].clientX - rect.left, y: event.touches[0].clientY - rect.top };
                return { x: event.clientX - rect.left, y: event.clientY - rect.top };
            };
            const startDrawing = (e) => { 
                e.preventDefault(); 
                isDrawing = true; 
                lines.push([]); 
                const { x, y } = getCoordinates(e); 
                lines[lines.length - 1].push(canvasToGraph(x, y)); 
                isDrawingVisible = true; // Make sure drawing is visible when starting a new one
                toggleDrawingBtn.classList.add('hidden');
                redrawScene(); 
            };
            const draw = (e) => { if (!isDrawing) return; e.preventDefault(); const { x, y } = getCoordinates(e); lines[lines.length - 1].push(canvasToGraph(x, y)); redrawScene(); };
            const stopDrawing = () => { isDrawing = false; };

            const matrix_transpose = (m) => m[0].map((_, i) => m.map(row => row[i]));
            const matrix_multiply = (a, b) => a.map((row, i) => b[0].map((_, j) => row.reduce((sum, _, k) => sum + a[i][k] * b[k][j], 0)));
            const solveLinearSystem = (matrix) => {
                 const n = matrix.length;
                for (let i = 0; i < n; i++) {
                    let maxEl = Math.abs(matrix[i][i]), maxRow = i; for (let k = i + 1; k < n; k++) if (Math.abs(matrix[k][i]) > maxEl) { maxEl = Math.abs(matrix[k][i]); maxRow = k; }
                    for (let k = i; k < n + 1; k++) [matrix[maxRow][k], matrix[i][k]] = [matrix[i][k], matrix[maxRow][k]];
                    for (let k = i + 1; k < n; k++) { let c = -matrix[k][i] / matrix[i][i]; for (let j = i; j < n + 1; j++) if (i === j) matrix[k][j] = 0; else matrix[k][j] += c * matrix[i][j]; }
                }
                const solution = new Array(n);
                for (let i = n - 1; i > -1; i--) { solution[i] = matrix[i][n] / matrix[i][i]; for (let k = i - 1; k > -1; k--) matrix[k][n] -= matrix[k][i] * solution[i]; }
                return solution;
            };
            // --- ALL REGRESSION AND FORMATTING FUNCTIONS ---
            const polynomialRegression = (data, degree) => { const n = degree + 1; const matrix = Array.from({ length: n }, () => new Array(n + 1).fill(0)); for (let i = 0; i < n; i++) { for (let j = 0; j < n; j++) { matrix[i][j] = data.reduce((sum, p) => sum + Math.pow(p.x, i + j), 0); } matrix[i][n] = data.reduce((sum, p) => sum + p.y * Math.pow(p.x, i), 0); } return solveLinearSystem(matrix); };
            const calculateRSquared = (data, coefficients) => { const yMean = data.reduce((sum, p) => sum + p.y, 0) / data.length; const predict = (x) => coefficients.reduce((sum, c, i) => sum + c * Math.pow(x, i), 0); const ssr = data.reduce((sum, p) => sum + Math.pow(p.y - predict(p.x), 2), 0); const sst = data.reduce((sum, p) => sum + Math.pow(p.y - yMean, 2), 0); return sst === 0 ? 1 : 1 - (ssr / sst); };
            const exponentialRegression = (data) => { const logData = data.filter(p => p.y > 0).map(p => ({ x: p.x, y: Math.log(p.y) })); if (logData.length < 2) return null; const coeffs = polynomialRegression(logData, 1); if (!coeffs || coeffs.length < 2) return null; const intercept = coeffs[0], slope = coeffs[1]; return { a: Math.exp(intercept), b: slope }; };
            const calculateRSquaredExponential = (data, params) => { if (!params) return -Infinity; const yMean = data.reduce((sum, p) => sum + p.y, 0) / data.length; const predict = (x) => params.a * Math.exp(params.b * x); let ssr = 0, sst = 0; data.forEach(p => { const predictedY = predict(p.x); if (isFinite(predictedY)) { ssr += Math.pow(p.y - predictedY, 2); sst += Math.pow(p.y - yMean, 2); } }); if (sst === 0) return 1; return 1 - (ssr / sst); };
            const trigonometricRegression = (data) => { if (data.length < 5) return null; let yMin = Infinity, yMax = -Infinity; data.forEach(p => { yMin = Math.min(yMin, p.y); yMax = Math.max(yMax, p.y); }); const amplitude = (yMax - yMin) / 2, verticalShift = (yMax + yMin) / 2; if (amplitude < (yMax - yMin) * 0.1) return null; const crossings = []; for (let i = 1; i < data.length; i++) { const p1 = data[i - 1], p2 = data[i]; if ((p1.y - verticalShift) * (p2.y - verticalShift) < 0) crossings.push({ x: p1.x + (p2.x - p1.x) * (verticalShift - p1.y) / (p2.y - p1.y) }); } if (crossings.length < 2) return null; const periods = []; for (let i = 2; i < crossings.length; i++) periods.push(2 * Math.abs(crossings[i].x - crossings[i - 2].x)); if (periods.length === 0 && crossings.length >= 2) { const numHalfPeriods = crossings.length - 1; const totalDistance = crossings[crossings.length - 1].x - crossings[0].x; if (numHalfPeriods > 0 && totalDistance > 0) periods.push(2 * (totalDistance / numHalfPeriods)); } if (periods.length === 0) return null; const avgPeriod = periods.reduce((sum, p) => sum + p, 0) / periods.length; if (avgPeriod <= 1e-6) return null; const frequency = (2 * Math.PI) / avgPeriod; const p0 = data[0]; const safeAmplitude = Math.max(amplitude, 1e-6); const initialVal = Math.max(-1, Math.min(1, (p0.y - verticalShift) / safeAmplitude)); const initialAngle = Math.asin(initialVal); const phaseShift1 = initialAngle - frequency * p0.x, phaseShift2 = Math.PI - initialAngle - frequency * p0.x; const p1 = data[1] || data[0]; const err1 = Math.abs((amplitude * Math.sin(frequency * p1.x + phaseShift1) + verticalShift) - p1.y); const err2 = Math.abs((amplitude * Math.sin(frequency * p1.x + phaseShift2) + verticalShift) - p1.y); const phaseShift = err1 < err2 ? phaseShift1 : phaseShift2; return { A: amplitude, B: frequency, C: phaseShift, D: verticalShift }; };
            const calculateRSquaredTrig = (data, params) => { if (!params) return -Infinity; const yMean = data.reduce((sum, p) => sum + p.y, 0) / data.length; const predict = (x) => params.A * Math.sin(params.B * x + params.C) + params.D; const ssr = data.reduce((sum, p) => sum + Math.pow(p.y - predict(p.x), 2), 0); const sst = data.reduce((sum, p) => sum + Math.pow(p.y - yMean, 2), 0); return sst === 0 ? 1 : 1 - (ssr / sst); };
            const reciprocalRegression = (data) => { let sumXY = 0, validPoints = 0; data.forEach(p => { if (Math.abs(p.x) > 1e-6) { sumXY += p.x * p.y; validPoints++; } }); if (validPoints < 5) return null; return { A: sumXY / validPoints }; };
            const calculateRSquaredReciprocal = (data, params) => { if (!params) return -Infinity; const yMean = data.reduce((sum, p) => sum + p.y, 0) / data.length; const predict = (x) => Math.abs(x) < 1e-6 ? Infinity : params.A / x; let ssr = 0, sst = 0, validPoints = 0; data.forEach(p => { const predictedY = predict(p.x); if (isFinite(predictedY)) { ssr += Math.pow(p.y - predictedY, 2); sst += Math.pow(p.y - yMean, 2); validPoints++; } }); if (validPoints === 0 || sst === 0) return -Infinity; return 1 - (ssr / sst); };
            const circleRegression = (data) => { if (data.length < 3) return null; let sumX = 0, sumY = 0, sumX2 = 0, sumY2 = 0, sumXY = 0; let sumX3 = 0, sumY3 = 0, sumX2Y = 0, sumXY2 = 0; const n = data.length; for (const p of data) { const x = p.x, y = p.y, x2 = x * x, y2 = y * y; sumX += x; sumY += y; sumX2 += x2; sumY2 += y2; sumXY += x * y; sumX3 += x * x2; sumY3 += y * y2; sumX2Y += x2 * y; sumXY2 += x * y2; } const A = n * sumX2 - sumX * sumX, B = n * sumXY - sumX * sumY, C = n * sumY2 - sumY * sumY; const D = 0.5 * (n * sumXY2 - sumX * sumY2 + n * sumX3 - sumX * sumX2); const E = 0.5 * (n * sumX2Y - sumY * sumX2 + n * sumY3 - sumY * sumY2); const det = A * C - B * B; if (Math.abs(det) < 1e-10) return null; const h = (D * C - B * E) / det, k = (A * E - B * D) / det; const rSquared = data.reduce((sum, p) => sum + Math.pow(p.x - h, 2) + Math.pow(p.y - k, 2), 0) / n; return { h, k, r: Math.sqrt(rSquared) }; };
            const calculateRSquaredCircle = (data, params) => { if (!params) return -Infinity; const { h, k, r } = params; const radiusVariation = data.reduce((sum, p) => sum + Math.pow(Math.sqrt(Math.pow(p.x - h, 2) + Math.pow(p.y - k, 2)) - r, 2), 0); const xMean = data.reduce((sum, p) => sum + p.x, 0) / data.length; const yMean = data.reduce((sum, p) => sum + p.y, 0) / data.length; const totalVariation = data.reduce((sum, p) => sum + Math.pow(p.x - xMean, 2) + Math.pow(p.y - yMean, 2), 0); if (totalVariation === 0) return 1; return 1 - (radiusVariation / totalVariation); };
            const tangentRegression = (lines, allPoints) => { if (lines.length < 2 || allPoints.length < 10) return null; const areLinesIncreasing = lines.every(line => { if (line.length < 2) return false; return (line[line.length - 1].y - line[0].y) / (line[line.length - 1].x - line[0].x) > 0.1; }); if (!areLinesIncreasing) return null; const midpoints = lines.map(line => line[Math.floor(line.length / 2)]).sort((a, b) => a.x - b.x); if (midpoints.length < 2) return null; const periods = []; for (let i = 1; i < midpoints.length; i++) periods.push(midpoints[i].x - midpoints[i - 1].x); const avgPeriod = periods.reduce((sum, p) => sum + p, 0) / periods.length; if (avgPeriod <= 1e-6) return null; const frequency = Math.PI / avgPeriod; const verticalShift = midpoints.reduce((sum, p) => sum + p.y, 0) / midpoints.length; const horizontalShift = -frequency * midpoints[0].x; let sumA = 0, countA = 0; lines.forEach(line => { const samplePoint = line[Math.floor(line.length * 0.25)]; const tanVal = Math.tan(frequency * samplePoint.x + horizontalShift); if (Math.abs(tanVal) > 1e-2) { sumA += (samplePoint.y - verticalShift) / tanVal; countA++; } }); if (countA === 0) return null; return { A: sumA / countA, B: frequency, C: horizontalShift, D: verticalShift }; };
            const calculateRSquaredTangent = (data, params) => { if (!params) return -Infinity; const yMean = data.reduce((sum, p) => sum + p.y, 0) / data.length; const predict = (x) => params.A * Math.tan(params.B * x + params.C) + params.D; let ssr = 0, sst = 0, validPoints = 0; data.forEach(p => { const predictedY = predict(p.x); if (isFinite(predictedY)) { ssr += Math.pow(p.y - predictedY, 2); sst += Math.pow(p.y - yMean, 2); validPoints++; } }); if (validPoints < 5 || sst === 0) return -Infinity; return 1 - (ssr / sst); };
            const ellipseRegression = (data) => { if (data.length < 5) return null; const M = data.map(p => [p.x * p.x, p.x * p.y, p.y * p.y, p.x, p.y]); const MT = matrix_transpose(M); const MTM = matrix_multiply(MT, M); const MTb = new Array(5).fill(0); for (let i = 0; i < 5; i++) for (let j = 0; j < data.length; j++) MTb[i] -= MT[i][j]; const matrixForSolver = MTM.map((row, i) => [...row, MTb[i]]); const coeffs = solveLinearSystem(matrixForSolver); if (!coeffs || coeffs.some(isNaN)) return null; const [A, B, C, D, E] = coeffs, F = -1; const det = B * B - 4 * A * C; if (det >= 0) return null; const h = (2 * C * D - B * E) / det, k = (2 * A * E - B * D) / det; const angle = 0.5 * Math.atan2(B, A - C); const term = 2 * (A * h * h + B * h * k + C * k * k - F); const common = Math.sqrt(Math.pow(A - C, 2) + B * B); const a_sq = term / (A + C + common), b_sq = term / (A + C - common); if (a_sq <= 0 || b_sq <= 0) return null; return { h, k, a: Math.sqrt(a_sq), b: Math.sqrt(b_sq), angle, coeffs: [A, B, C, D, E, F] }; };
            const calculateRSquaredEllipse = (data, params) => { if (!params) return -Infinity; const { h, k, a, b, angle } = params; const cos = Math.cos(angle), sin = Math.sin(angle); const predictRadius = (theta) => (a * b) / Math.sqrt(Math.pow(b * Math.cos(theta), 2) + Math.pow(a * Math.sin(theta), 2)); let ssr = 0; data.forEach(p => { const dx = p.x - h, dy = p.y - k; const pointAngle = Math.atan2(dy, dx), rotatedAngle = pointAngle - angle, expectedR = predictRadius(rotatedAngle), actualR = Math.hypot(dx, dy); ssr += Math.pow(actualR - expectedR, 2); }); const xMean = data.reduce((sum, p) => sum + p.x, 0) / data.length; const yMean = data.reduce((sum, p) => sum + p.y, 0) / data.length; const sst = data.reduce((sum, p) => sum + Math.pow(p.x - xMean, 2) + Math.pow(p.y - yMean, 2), 0); if (sst === 0) return 1; return 1 - (ssr / sst); };
            
            const formatExponential = (params) => !params ? null : `${params.a.toFixed(2)} * exp(${params.b.toFixed(2)}*x)`;
            const formatEllipse = (params) => { if (!params) return null; const { h, k, a, b, angle } = params; const angleDeg = (angle * 180 / Math.PI).toFixed(1); const r1 = Math.max(a, b), r2 = Math.min(a, b); return `Ellipse: center(${h.toFixed(2)}, ${k.toFixed(2)}), radii(${r1.toFixed(2)}, ${r2.toFixed(2)}), angle ${angleDeg}°`; };
            const formatTangent = (params) => { if (!params) return null; let { A, B, C, D } = params, result = '', tanInner = ''; if (Math.abs(A - 1) > 1e-2) result += A.toFixed(2) + '*'; if (Math.abs(B - 1) > 1e-2) tanInner += B.toFixed(2) + '*x'; else tanInner += 'x'; if (Math.abs(C) > 1e-2) tanInner += (C > 0 ? ' + ' : ' - ') + Math.abs(C).toFixed(2); result += `tan(${tanInner})`; if (Math.abs(D) > 1e-2) result += (D > 0 ? ' + ' : ' - ') + Math.abs(D).toFixed(2); return result; };
            const formatTrigonometric = (params) => { if (!params) return null; let { A, B, C, D } = params; if (A < 0) { A = -A; C += Math.PI; } let result = '', sinInner = ''; if (Math.abs(A - 1) > 1e-2) result += A.toFixed(2) + '*'; if (Math.abs(B - 1) > 1e-2) sinInner += B.toFixed(2) + '*x'; else sinInner += 'x'; if (Math.abs(C) > 1e-2) sinInner += (C > 0 ? ' + ' : ' - ') + Math.abs(C).toFixed(2); result += `sin(${sinInner})`; if (Math.abs(D) > 1e-2) result += (D > 0 ? ' + ' : ' - ') + Math.abs(D).toFixed(2); return result; };
            const formatReciprocal = (params) => !params ? null : `${params.A.toFixed(2)} / x`;
            const formatCircle = (params) => { if (!params) return null; const { h, k, r } = params; const xPart = h !== 0 ? `(x ${h > 0 ? '-' : '+'} ${Math.abs(h).toFixed(2)})^2` : 'x^2'; const yPart = k !== 0 ? `(y ${k > 0 ? '-' : '+'} ${Math.abs(k).toFixed(2)})^2` : 'y^2'; return `${xPart} + ${yPart} = ${r.toFixed(2)}^2`; };
            const formatPolynomial = (coefficients) => { if (!coefficients || coefficients.length === 0) return '0.00'; let parts = []; for (let i = coefficients.length - 1; i >= 0; i--) { const c = coefficients[i]; if (Math.abs(c) < 1e-6) continue; const absC = Math.abs(c), sign = c > 0 ? '+' : '-'; const isCoeffOne = Math.abs(absC - 1) < 1e-6; let term = ''; if (!isCoeffOne || i === 0) term += absC.toFixed(2); if (i > 0) { term += (term !== '' ? '*' : '') + 'x'; if (i > 1) term += `^${i}`; } if (term !== '') { if (parts.length > 0) parts.push(sign, term); else { if (sign === '-') term = term.includes('^') ? `(-1)*${term}` : `-${term}`; parts.push(term); } } } if (parts.length === 0) return '0.00'; return parts.join(' ').replace(/\+ -/g, '-'); };
            
            const formatFormula = (fit) => {
                if (!fit) return null;
                let formulaString;
                let formulaInfo = { type: fit.type, params: fit.params };
                switch(fit.type) {
                    case 'polynomial':    formulaString = formatPolynomial(fit.coefficients); formulaInfo.formula = formulaString; formulaInfo.params = { coefficients: fit.coefficients }; break;
                    case 'exponential':   formulaString = formatExponential(fit.params);      formulaInfo.formula = formulaString; break;
                    case 'trigonometric': formulaString = formatTrigonometric(fit.params);    formulaInfo.formula = formulaString; break;
                    case 'reciprocal':    formulaString = formatReciprocal(fit.params);     formulaInfo.formula = formulaString; break;
                    case 'tangent':       formulaString = formatTangent(fit.params);        formulaInfo.formula = formulaString; break;
                    case 'circle':        formulaString = formatCircle(fit.params);         formulaInfo.formula = formulaString; break;
                    case 'ellipse':       formulaString = formatEllipse(fit.params);        formulaInfo.formula = formulaString; break;
                }
                return formulaString ? formulaInfo : null;
            };

            const segmentDrawing = (lines) => {
                const segments = [];
                const CUSP_THRESHOLD = Math.PI / 1.8; // 100 degrees
                lines.forEach(line => {
                    if (line.length < 3) {
                        segments.push(line);
                        return;
                    }
                    let currentSegment = [line[0]];
                    for (let i = 1; i < line.length - 1; i++) {
                        currentSegment.push(line[i]);
                        const p1 = line[i-1], p2 = line[i], p3 = line[i+1];
                        const angle1 = Math.atan2(p2.y - p1.y, p2.x - p1.x);
                        const angle2 = Math.atan2(p3.y - p2.y, p3.x - p2.x);
                        let angleChange = Math.abs(angle1 - angle2);
                        if (angleChange > Math.PI) angleChange = 2 * Math.PI - angleChange;

                        if (angleChange > CUSP_THRESHOLD) {
                            segments.push(currentSegment);
                            currentSegment = [line[i]];
                        }
                    }
                    currentSegment.push(line[line.length - 1]);
                    segments.push(currentSegment);
                });
                return segments.filter(s => s.length > 5);
            };
            
            const findBestFitForSegment = (segmentPoints, isClosedLoop) => {
                const xMin = Math.min(...segmentPoints.map(p => p.x));
                const xMax = Math.max(...segmentPoints.map(p => p.x));
                const domain = { xMin, xMax };
                let fits = [];
                
                if (forceGraphType === 'auto' || forceGraphType === 'line' || forceGraphType === 'quadratic' || forceGraphType === 'cubic') {
                    let bestPolyFit = { rSquared: -Infinity };
                    const minDegree = forceGraphType === 'line' ? 1 : (forceGraphType === 'quadratic' ? 2 : (forceGraphType === 'cubic' ? 3 : 1));
                    const maxDegree = forceGraphType === 'line' ? 1 : (forceGraphType === 'quadratic' ? 2 : (forceGraphType === 'cubic' ? 3 : 4));
                    for (let degree = minDegree; degree <= maxDegree; degree++) {
                        const coeffs = polynomialRegression(segmentPoints, degree);
                        if (coeffs) {
                            const rSquared = calculateRSquared(segmentPoints, coeffs) - (forceGraphType === 'auto' ? (degree * 0.01) : 0);
                            if (rSquared > bestPolyFit.rSquared) bestPolyFit = { rSquared, coefficients: coeffs };
                        }
                    }
                    if (bestPolyFit.coefficients) fits.push({ type: 'polynomial', ...bestPolyFit });
                }

                if (forceGraphType === 'auto' || forceGraphType === 'exponential') {
                    const expParams = exponentialRegression(segmentPoints);
                    if (expParams) fits.push({ type: 'exponential', rSquared: calculateRSquaredExponential(segmentPoints, expParams), params: expParams });
                }

                if (forceGraphType === 'auto' || forceGraphType === 'trigonometric') {
                    const trigParams = trigonometricRegression(segmentPoints);
                    if (trigParams) fits.push({ type: 'trigonometric', rSquared: calculateRSquaredTrig(segmentPoints, trigParams), params: trigParams });
                    
                    const tangentParams = tangentRegression([segmentPoints], segmentPoints);
                    if (tangentParams) fits.push({ type: 'tangent', rSquared: calculateRSquaredTangent(segmentPoints, tangentParams), params: tangentParams });
                }
                
                if (forceGraphType === 'auto' || forceGraphType === 'reciprocal') {
                    const reciprocalParams = reciprocalRegression(segmentPoints);
                    if (reciprocalParams) fits.push({ type: 'reciprocal', rSquared: calculateRSquaredReciprocal(segmentPoints, reciprocalParams), params: reciprocalParams });
                }

                if (forceGraphType === 'auto' || forceGraphType === 'circle') {
                    const circleParams = circleRegression(segmentPoints);
                    if (circleParams) fits.push({ type: 'circle', rSquared: calculateRSquaredCircle(segmentPoints, circleParams) + (isClosedLoop ? 0.1 : 0), params: circleParams });
                }

                if (forceGraphType === 'auto' || forceGraphType === 'ellipse') {
                    const ellipseParams = ellipseRegression(segmentPoints);
                    if (ellipseParams) fits.push({ type: 'ellipse', rSquared: calculateRSquaredEllipse(segmentPoints, ellipseParams) + (isClosedLoop ? 0.15 : 0), params: ellipseParams });
                }

                if (fits.length === 0) return null;
                fits.sort((a, b) => b.rSquared - a.rSquared);
                const bestFit = fits[0];
                bestFit.domain = domain;
                return bestFit;
            };

            const analyzeGraph = () => {
                const allPoints = lines.flat();
                if (allPoints.length < 10) {
                    resultEl.innerHTML = `<span class="placeholder" style="color: #d9534f;">Please draw a more complete graph.</span>`;
                    return;
                }

                analyzeBtn.disabled = true; analyzeBtn.textContent = "Analyzing...";
                drawFuncBtn.disabled = true; analyzedFormulas = []; formulasToDraw = [];
                toggleDrawingBtn.classList.add('hidden');
                redrawScene(); 
                
                setTimeout(() => {
                    try {
                        const startPointGlobal = allPoints[0], endPointGlobal = allPoints[allPoints.length - 1];
                        const isClosedLoopGlobal = lines.length === 1 && Math.hypot(startPointGlobal.x - endPointGlobal.x, startPointGlobal.y - endPointGlobal.y) < (getRange().max - getRange().min) * 0.2;
                        
                        if (forceGraphType !== 'auto') {
                             const segments = (forceGraphType === 'circle' || forceGraphType === 'ellipse') ? [allPoints] : segmentDrawing(lines);
                             const topSegments = segments.sort((a, b) => b.length - a.length).slice(0, 5);
                             topSegments.forEach(segment => {
                                 const bestFit = findBestFitForSegment(segment, isClosedLoopGlobal);
                                 if (bestFit) {
                                     const formulaInfo = formatFormula(bestFit);
                                     if(formulaInfo) {
                                        formulaInfo.domain = bestFit.domain;
                                        analyzedFormulas.push(formulaInfo);
                                     }
                                 }
                             });
                        } else {
                            const singleBestFit = findBestFitForSegment(allPoints, isClosedLoopGlobal);
                            const HIGH_FIT_THRESHOLD = 0.95;

                            if (singleBestFit && singleBestFit.rSquared > HIGH_FIT_THRESHOLD) {
                                const formulaInfo = formatFormula(singleBestFit);
                                if (formulaInfo) {
                                    formulaInfo.domain = singleBestFit.domain;
                                    analyzedFormulas.push(formulaInfo);
                                }
                            } else {
                                const segments = segmentDrawing(lines);
                                const topSegments = segments.sort((a, b) => b.length - a.length).slice(0, 5);
                                topSegments.forEach(segment => {
                                    const bestFit = findBestFitForSegment(segment, isClosedLoopGlobal);
                                    if (bestFit) {
                                        const formulaInfo = formatFormula(bestFit);
                                        if(formulaInfo) {
                                            formulaInfo.domain = bestFit.domain;
                                            analyzedFormulas.push(formulaInfo);
                                        }
                                    }
                                });
                                
                                if (analyzedFormulas.length === 0 && singleBestFit) {
                                    const formulaInfo = formatFormula(singleBestFit);
                                    if (formulaInfo) {
                                        formulaInfo.domain = singleBestFit.domain;
                                        analyzedFormulas.push(formulaInfo);
                                    }
                                }
                            }
                        }

                        if (analyzedFormulas.length === 0) throw new Error("Could not find any high-quality function fits.");

                        let resultHTML = '<ol>';
                        analyzedFormulas.forEach((info, index) => {
                            const color = plotColors[index % plotColors.length];
                            const prefix = (info.type === 'polynomial' || info.type === 'reciprocal' || info.type === 'tangent' || info.type === 'trigonometric' || info.type === 'exponential') ? 'f(x) &approx; ' : '';
                            resultHTML += `<li><span class="color-swatch" style="background-color: ${color};"></span><strong>${prefix}${info.formula}</strong></li>`;
                        });
                        resultHTML += '</ol>';
                        resultEl.innerHTML = resultHTML;
                        
                        if (analyzedFormulas.length === 1 && ['polynomial', 'trigonometric', 'tangent', 'reciprocal', 'exponential'].includes(analyzedFormulas[0].type)) {
                           functionInput.value = analyzedFormulas[0].formula;
                        } else {
                           functionInput.value = '';
                        }
                        
                        drawFuncBtn.disabled = false;

                    } catch (error) {
                        console.error("Error analyzing graph:", error);
                        resultEl.innerHTML = `<span class="placeholder" style="color: #d9534f;">Could not analyze graph. ${error.message}</span>`;
                    } finally {
                        analyzeBtn.disabled = false;
                        analyzeBtn.textContent = "Analyze";
                    }
                }, 50);
            };
            
            const calculateOptimalRange = (func, currentXRange) => {
                const { min: minX, max: maxX } = currentXRange; if (maxX <= minX) return null;
                let minY = Infinity, maxY = -Infinity; let validPointsFound = false;
                for (let i = 0; i <= 500; i++) {
                    const x = minX + (i / 500) * (maxX - minX); let y; try { y = func(x); } catch (e) { continue; }
                    if (typeof y === 'number' && isFinite(y)) { minY = Math.min(minY, y); maxY = Math.max(maxY, y); validPointsFound = true; }
                }
                if (!validPointsFound) return null;
                const yRange = maxY - minY; const padding = yRange === 0 ? 1 : yRange * 0.1;
                minY -= padding; maxY += padding; const newRangeMin = Math.min(minX, minY), newRangeMax = Math.max(maxX, maxY);
                const finalSize = Math.max(Math.abs(newRangeMin), Math.abs(newRangeMax));
                return { min: -finalSize, max: finalSize };
            };
            
            analyzeBtn.addEventListener('click', analyzeGraph);
            clearBtn.addEventListener('click', reset);
            
            updateRangeBtn.addEventListener('click', () => {
                const { min, max } = getRange(); minRangeInput.value = min; maxRangeInput.value = max; redrawScene();
            });

            functionInput.addEventListener('input', () => {
                const hasText = functionInput.value.trim().length > 0;
                drawFuncBtn.disabled = !hasText;
                if (hasText) { analyzedFormulas = []; formulasToDraw = []; }
            });

            drawFuncBtn.addEventListener('click', () => {
                formulasToDraw = [];
                const formula = functionInput.value.trim();
                if (formula.length > 0) {
                     const func = sanitizeAndCreateFunction(formula);
                     if (func) {
                         const newRange = calculateOptimalRange(func, getRange());
                         if (newRange) {
                            let { min, max } = newRange; const limit = 30; min = Math.max(-limit, min); max = Math.min(limit, max);
                            minRangeInput.value = min.toFixed(2); maxRangeInput.value = max.toFixed(2);
                         }
                         formulasToDraw = [{ type: 'standard', formula: formula }];
                     }
                } else if (analyzedFormulas.length > 0) {
                    formulasToDraw = analyzedFormulas;
                }
                redrawScene();
                toggleDrawingBtn.classList.remove('hidden');
            });
            
            toggleDrawingBtn.addEventListener('click', () => {
                isDrawingVisible = !isDrawingVisible;
                toggleDrawingBtn.textContent = isDrawingVisible ? 'Hide Drawing' : 'Show Drawing';
                redrawScene();
            });

            forceBtns.forEach(btn => {
                btn.addEventListener('click', () => {
                    forceBtns.forEach(b => b.classList.remove('active'));
                    btn.classList.add('active');
                    forceGraphType = btn.dataset.type;
                });
            });

            canvas.addEventListener('mousedown', startDrawing); canvas.addEventListener('mousemove', draw);
            canvas.addEventListener('mouseup', stopDrawing); canvas.addEventListener('mouseleave', stopDrawing);
            canvas.addEventListener('touchstart', startDrawing, { passive: false }); canvas.addEventListener('touchmove', draw, { passive: false });
            canvas.addEventListener('touchend', stopDrawing);

            reset();
        });
    </script>
</body>
</html>
