
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Graph Analyzer</title>
    <style>
        body, html {
            margin: 0;
            padding: 0;
            width: 100%;
            height: 100%;
            display: flex;
            justify-content: center;
            align-items: center;
            background-color: #f0f2f5;
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
            overflow: hidden;
        }
        .container {
            display: flex;
            flex-direction: column;
            align-items: center;
            width: 100%;
            padding: 1rem;
            box-sizing: border-box;
        }
        h1 {
            color: #333;
            font-size: 1.5rem;
            margin: 0 0 1rem 0;
            text-align: center;
        }
        .range-controls {
            display: flex;
            gap: 0.5rem;
            align-items: center;
            margin-bottom: 0.5rem;
            color: #555;
            font-size: 0.9rem;
        }
        .range-controls input {
            width: 60px;
            padding: 0.5rem;
            border: 1px solid #ccc;
            border-radius: 4px;
            font-size: 1rem;
            text-align: center;
        }
        #updateRangeBtn {
            margin-bottom: 1rem;
            background-color: #6c757d;
            color: white;
            padding: 0.5rem 1rem;
            font-size: 0.9rem;
        }
        #updateRangeBtn:hover {
            background-color: #5a6268;
        }
        .input-prompt {
            color: #666;
            font-size: 0.9rem;
            margin-bottom: 0.5rem;
            text-align: center;
        }
        .function-input-container {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            margin-bottom: 1rem;
            width: 90%;
            max-width: 380px;
        }
        .function-input-container label {
            font-family: 'SF Mono', 'Courier New', monospace;
            font-size: 1.1rem;
            color: #333;
        }
        .function-input-container input {
            flex-grow: 1;
            padding: 0.5rem;
            border: 1px solid #ccc;
            border-radius: 4px;
            font-size: 1rem;
            font-family: 'SF Mono', 'Courier New', monospace;
        }
        canvas {
            background-color: #ffffff;
            border: 2px solid #cccccc;
            border-radius: 8px;
            box-shadow: 0 4px 8px rgba(0,0,0,0.1);
            cursor: crosshair;
            touch-action: none;
        }
        .controls {
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            gap: 1rem;
            margin-top: 1rem;
        }
        button {
            padding: 0.75rem 1.5rem;
            font-size: 1rem;
            font-weight: 600;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            transition: background-color 0.2s ease, transform 0.1s ease;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            -webkit-tap-highlight-color: transparent;
        }
        button:active {
            transform: scale(0.98);
        }
        #analyzeBtn {
            background-color: #007bff;
            color: white;
        }
        #analyzeBtn:hover:not(:disabled) {
            background-color: #0056b3;
        }
        #analyzeBtn:disabled {
            background-color: #a0c7ff;
            cursor: not-allowed;
        }
        #drawFuncBtn {
            background-color: #28a745;
            color: white;
        }
        #drawFuncBtn:hover:not(:disabled) {
            background-color: #218838;
        }
        #drawFuncBtn:disabled {
            background-color: #94dcb0;
            cursor: not-allowed;
        }
        #clearBtn {
            background-color: #f1f3f5;
            color: #333;
            border: 1px solid #ddd;
        }
        #clearBtn:hover {
            background-color: #e2e6ea;
        }
        #result-container {
            margin-top: 1rem;
            padding: 1rem;
            background-color: #ffffff;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.05);
            min-height: 50px;
            width: 90%;
            max-width: 380px;
            display: flex;
            justify-content: center;
            align-items: center;
            text-align: center;
            box-sizing: border-box;
        }
        #result {
            font-family: 'SF Mono', 'Courier New', monospace;
            font-size: 1.1rem;
            color: #333;
            word-break: break-all;
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }
        #result .placeholder {
            color: #999;
            font-style: italic;
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
            font-size: 1rem;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>Graph Analyzer</h1>
        <div class="range-controls">
            <label for="minRange">Min:</label>
            <input type="number" id="minRange" value="-8" step="1">
            <label for="maxRange">Max:</label>
            <input type="number" id="maxRange" value="8" step="1">
        </div>
        <button id="updateRangeBtn">Update Range</button>
        <p class="input-prompt">Either input a function or draw a graph to analyze</p>
        <div class="function-input-container">
            <label for="functionInput">f(x) =</label>
            <input type="text" id="functionInput" placeholder="e.g., sin(x) * 5">
        </div>
        <canvas id="drawCanvas"></canvas>
        <div class="controls">
            <button id="analyzeBtn">Analyze</button>
            <button id="drawFuncBtn" disabled>Draw Function</button>
            <button id="clearBtn">Clear</button>
        </div>
        <div id="result-container">
            <p id="result">
                <span class="placeholder">Draw a function and click "Analyze"</span>
            </p>
        </div>
    </div>

    <script type="module">
        document.addEventListener('DOMContentLoaded', () => {
            // DOM Elements
            const canvas = document.getElementById('drawCanvas');
            const analyzeBtn = document.getElementById('analyzeBtn');
            const clearBtn = document.getElementById('clearBtn');
            const drawFuncBtn = document.getElementById('drawFuncBtn');
            const resultEl = document.getElementById('result');
            const minRangeInput = document.getElementById('minRange');
            const maxRangeInput = document.getElementById('maxRange');
            const updateRangeBtn = document.getElementById('updateRangeBtn');
            const functionInput = document.getElementById('functionInput');
            const ctx = canvas.getContext('2d');
            
            // Additional elements for sizing
            const container = document.querySelector('.container');
            const h1 = document.querySelector('h1');
            const rangeControls = document.querySelector('.range-controls');
            const controls = document.querySelector('.controls');
            const resultContainer = document.getElementById('result-container');
            const inputPrompt = document.querySelector('.input-prompt');
            const functionInputContainer = document.querySelector('.function-input-container');

            if (!canvas || !ctx || !analyzeBtn || !clearBtn || !drawFuncBtn || !resultEl || !minRangeInput || !maxRangeInput || !updateRangeBtn || !functionInput || !container || !h1 || !rangeControls || !controls || !resultContainer || !inputPrompt || !functionInputContainer) {
                console.error('Essential DOM elements not found.');
                return;
            }

            // --- Canvas Size Calculation ---
            const remToPx = (rem) => rem * parseFloat(getComputedStyle(document.documentElement).fontSize);
            
            const verticalSpacing = 
                remToPx(1) + // container padding-top
                remToPx(1) + // h1 margin-bottom
                remToPx(0.5) + // range-controls margin-bottom
                remToPx(1) + // updateRangeBtn margin-bottom
                remToPx(0.5) + // input-prompt margin-bottom
                remToPx(1) + // function-input-container margin-bottom
                remToPx(1) + // controls margin-top
                remToPx(1) + // result-container margin-top
                remToPx(1);  // container padding-bottom

            const otherElementsHeight = 
                h1.offsetHeight + 
                rangeControls.offsetHeight + 
                updateRangeBtn.offsetHeight + 
                inputPrompt.offsetHeight +
                functionInputContainer.offsetHeight +
                controls.offsetHeight + 
                resultContainer.offsetHeight;

            const totalNonCanvasHeight = otherElementsHeight + verticalSpacing;
            
            const availableHeight = window.innerHeight - totalNonCanvasHeight;
            const availableWidth = container.clientWidth;
            
            const baseSize = Math.max(150, Math.floor(Math.min(availableWidth, availableHeight)));
            
            const dpr = window.devicePixelRatio || 1;
            canvas.width = baseSize * dpr;
            canvas.height = baseSize * dpr;
            canvas.style.width = `${baseSize}px`;
            canvas.style.height = `${baseSize}px`;
            ctx.scale(dpr, dpr);

            // App State
            let isDrawing = false;
            let lines = []; // Array of arrays to hold disconnected lines
            let analyzedFormula = null; // Stores formula from analysis
            let formulaToDraw = null; // Stores formula to be actively drawn

            // --- Coordinate Conversion ---
            const getRange = () => {
                const min = parseFloat(minRangeInput.value) || -8;
                const max = parseFloat(maxRangeInput.value) || 8;
                return { min, max };
            };

            const graphToCanvas = (gx, gy) => {
                const { min, max } = getRange();
                const range = max - min;
                if (range === 0) return { x: baseSize / 2, y: baseSize / 2 };
                const x = ((gx - min) / range) * baseSize;
                const y = baseSize - (((gy - min) / range) * baseSize);
                return { x, y };
            };

            const canvasToGraph = (cx, cy) => {
                const { min, max } = getRange();
                const range = max - min;
                const gx = (cx / baseSize) * range + min;
                const gy = ((baseSize - cy) / baseSize) * range + min;
                return { x: gx, y: gy };
            };

            // --- Drawing Functions ---
            const drawAxes = () => {
                const { min, max } = getRange();
                ctx.strokeStyle = '#cccccc';
                ctx.lineWidth = 1;
                ctx.font = `${12}px Arial`;
                ctx.fillStyle = '#888888';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';

                const origin = graphToCanvas(0, 0);

                ctx.beginPath();
                ctx.moveTo(origin.x, 0);
                ctx.lineTo(origin.x, baseSize);
                ctx.stroke();

                ctx.beginPath();
                ctx.moveTo(0, origin.y);
                ctx.lineTo(baseSize, origin.y);
                ctx.stroke();

                const tickCount = 5;
                const range = max - min;
                const step = range / tickCount;

                for (let i = 0; i <= tickCount; i++) {
                    const val = min + i * step;
                    const tickVal = parseFloat(val.toFixed(1));
                    const xTickPos = graphToCanvas(tickVal, 0);
                    ctx.fillText(tickVal.toString(), xTickPos.x, origin.y + 15);
                    if (tickVal !== 0) {
                        const yTickPos = graphToCanvas(0, tickVal);
                        ctx.textAlign = 'right';
                        ctx.fillText(tickVal.toString(), origin.x - 8, yTickPos.y);
                        ctx.textAlign = 'center';
                    }
                }
            };
            
            const drawUserPath = () => {
                ctx.strokeStyle = '#000000';
                ctx.lineWidth = 2.5;
                ctx.lineCap = 'round';
                ctx.lineJoin = 'round';

                lines.forEach(line => {
                    if (line.length < 2) return;
                    ctx.beginPath();
                    const startPoint = graphToCanvas(line[0].x, line[0].y);
                    ctx.moveTo(startPoint.x, startPoint.y);
                    for (let i = 1; i < line.length; i++) {
                        const point = graphToCanvas(line[i].x, line[i].y);
                        ctx.lineTo(point.x, point.y);
                    }
                    ctx.stroke();
                });
            };

            const drawFormulaOnCanvas = (formula) => {
                if (!formula) return;
                
                let sanitizedFormula = formula.trim()
                    .replace(/^f\(x\)\s*=\s*/i, '')
                    .replace(/\^/g, '**');

                const mathFunctions = ['sin', 'cos', 'tan', 'sqrt', 'exp', 'log', 'abs', 'PI', 'E'];
                mathFunctions.forEach(func => {
                    const regex = new RegExp(`\\b${func}\\b`, 'gi');
                    sanitizedFormula = sanitizedFormula.replace(regex, `Math.${func.toUpperCase()}`);
                });

                sanitizedFormula = sanitizedFormula.replace(/(\d)([a-zA-Z(])/g, '$1*$2');
                sanitizedFormula = sanitizedFormula.replace(/(\))([a-zA-Z\d(])/g, '$1*$2');
                sanitizedFormula = sanitizedFormula.replace(/x\(/g, 'x*(');

                try {
                    const func = new Function('x', `return ${sanitizedFormula}`);
                    const { min, max } = getRange();
                    
                    ctx.beginPath();
                    ctx.strokeStyle = '#007bff';
                    ctx.lineWidth = 2;
                    let firstPoint = true;
                    const steps = baseSize * 2; 

                    for (let i = 0; i <= steps; i++) {
                        const gx = min + (i / steps) * (max - min);
                        let gy;
                        try {
                             gy = func(gx);
                        } catch(e) {
                            firstPoint = true;
                            continue;
                        }
                        if (typeof gy !== 'number' || !isFinite(gy)) {
                            firstPoint = true;
                            continue;
                        }
                        const {x, y} = graphToCanvas(gx, gy);
                        if (firstPoint) {
                            ctx.moveTo(x, y);
                            firstPoint = false;
                        } else {
                            ctx.lineTo(x, y);
                        }
                    }
                    ctx.stroke();

                } catch (error) {
                    console.error("Error drawing formula graph:", error, sanitizedFormula);
                    resultEl.innerHTML += `<br><span class="placeholder" style="font-size: 0.8rem; color: #d9534f;">Could not plot formula.</span>`;
                }
            };

            const redrawScene = () => {
                ctx.clearRect(0, 0, baseSize, baseSize);
                drawAxes();
                drawUserPath();
                if (formulaToDraw) {
                    drawFormulaOnCanvas(formulaToDraw);
                }
            };

            const reset = () => {
                lines = [];
                analyzedFormula = null;
                formulaToDraw = null;
                functionInput.value = '';
                minRangeInput.value = '-8';
                maxRangeInput.value = '8';
                resultEl.innerHTML = `<span class="placeholder">Draw a function and click "Analyze"</span>`;
                analyzeBtn.disabled = false;
                analyzeBtn.textContent = "Analyze";
                drawFuncBtn.disabled = true;
                redrawScene();
            };

            // --- Event Handlers ---
            const getCoordinates = (event) => {
                const rect = canvas.getBoundingClientRect();
                if (event instanceof TouchEvent && event.touches.length > 0) {
                    return {
                        x: event.touches[0].clientX - rect.left,
                        y: event.touches[0].clientY - rect.top
                    };
                }
                return {
                    x: event.clientX - rect.left,
                    y: event.clientY - rect.top
                };
            };

            const startDrawing = (e) => {
                e.preventDefault();
                isDrawing = true;
                lines.push([]); 
                const { x, y } = getCoordinates(e);
                const graphPoint = canvasToGraph(x, y);
                lines[lines.length - 1].push(graphPoint); 
                redrawScene();
            };

            const draw = (e) => {
                if (!isDrawing) return;
                e.preventDefault();
                const { x, y } = getCoordinates(e);
                const graphPoint = canvasToGraph(x, y);
                lines[lines.length - 1].push(graphPoint); 
                redrawScene();
            };

            const stopDrawing = () => {
                isDrawing = false;
            };

            // --- In-Browser Analysis ---
            
            /**
             * Solves a system of linear equations using Gaussian elimination.
             */
            const solveLinearSystem = (matrix) => {
                const n = matrix.length;
                for (let i = 0; i < n; i++) {
                    let maxEl = Math.abs(matrix[i][i]);
                    let maxRow = i;
                    for (let k = i + 1; k < n; k++) {
                        if (Math.abs(matrix[k][i]) > maxEl) {
                            maxEl = Math.abs(matrix[k][i]);
                            maxRow = k;
                        }
                    }
                    for (let k = i; k < n + 1; k++) {
                        let tmp = matrix[maxRow][k];
                        matrix[maxRow][k] = matrix[i][k];
                        matrix[i][k] = tmp;
                    }
                    for (let k = i + 1; k < n; k++) {
                        let c = -matrix[k][i] / matrix[i][i];
                        for (let j = i; j < n + 1; j++) {
                            if (i === j) {
                                matrix[k][j] = 0;
                            } else {
                                matrix[k][j] += c * matrix[i][j];
                            }
                        }
                    }
                }
                const solution = new Array(n);
                for (let i = n - 1; i > -1; i--) {
                    solution[i] = matrix[i][n] / matrix[i][i];
                    for (let k = i - 1; k > -1; k--) {
                        matrix[k][n] -= matrix[k][i] * solution[i];
                    }
                }
                return solution;
            };
            
            /**
             * Performs polynomial regression on a set of data points.
             */
            const polynomialRegression = (data, degree) => {
                const n = degree + 1;
                const matrix = Array.from({ length: n }, () => new Array(n + 1).fill(0));
                
                for (let i = 0; i < n; i++) {
                    for (let j = 0; j < n; j++) {
                        matrix[i][j] = data.reduce((sum, p) => sum + Math.pow(p.x, i + j), 0);
                    }
                    matrix[i][n] = data.reduce((sum, p) => sum + p.y * Math.pow(p.x, i), 0);
                }
                
                return solveLinearSystem(matrix);
            };

            /**
             * Calculates the R-squared value for a polynomial fit.
             */
            const calculateRSquared = (data, coefficients) => {
                const yMean = data.reduce((sum, p) => sum + p.y, 0) / data.length;
                const predict = (x) => coefficients.reduce((sum, c, i) => sum + c * Math.pow(x, i), 0);
                const ssr = data.reduce((sum, p) => sum + Math.pow(p.y - predict(p.x), 2), 0);
                const sst = data.reduce((sum, p) => sum + Math.pow(p.y - yMean, 2), 0);
                return sst === 0 ? 1 : 1 - (ssr / sst);
            };
            
            /**
             * Performs trigonometric regression to fit data to A*sin(B*x + C) + D.
             */
            const trigonometricRegression = (data) => {
                if (data.length < 5) return null;

                let yMin = Infinity, yMax = -Infinity;
                data.forEach(p => {
                    if (p.y < yMin) yMin = p.y;
                    if (p.y > yMax) yMax = p.y;
                });

                const amplitude = (yMax - yMin) / 2;
                const verticalShift = (yMax + yMin) / 2;

                if (amplitude < 0.1 * (getRange().max - getRange().min)) return null;

                const crossings = [];
                for (let i = 1; i < data.length; i++) {
                    const p1 = data[i - 1];
                    const p2 = data[i];
                    if ((p1.y - verticalShift) * (p2.y - verticalShift) < 0) {
                        const x = p1.x + (p2.x - p1.x) * (verticalShift - p1.y) / (p2.y - p1.y);
                        const slope = (p2.y - p1.y) / (p2.x - p1.x);
                        crossings.push({ x, slope });
                    }
                }

                if (crossings.length < 2) return null;

                const periods = [];
                for (let i = 1; i < crossings.length; i++) {
                    if (crossings[i].slope > 0 && crossings[i-1].slope < 0 || crossings[i].slope < 0 && crossings[i-1].slope > 0) {
                         periods.push(2 * Math.abs(crossings[i].x - crossings[i-1].x));
                    }
                }
                if (periods.length === 0 && crossings.length >= 2) {
                   const numHalfPeriods = crossings.length - 1;
                   const totalDistance = crossings[crossings.length - 1].x - crossings[0].x;
                   if (numHalfPeriods > 0 && totalDistance > 0) {
                       periods.push(2 * (totalDistance / numHalfPeriods));
                   }
                }
                
                if (periods.length === 0) return null;

                const avgPeriod = periods.reduce((sum, p) => sum + p, 0) / periods.length;
                if (avgPeriod <= 1e-6) return null;
                
                const frequency = (2 * Math.PI) / avgPeriod;

                let firstUpwardCrossingX = null;
                for (const cross of crossings) {
                    if (cross.slope > 0) {
                        firstUpwardCrossingX = cross.x;
                        break;
                    }
                }
                
                let phaseShift = 0;
                if (firstUpwardCrossingX !== null) {
                    phaseShift = -frequency * firstUpwardCrossingX;
                } else {
                    const p0 = data[0];
                    if (amplitude > 1e-6) {
                        phaseShift = Math.asin((p0.y - verticalShift) / amplitude) - frequency * p0.x;
                    }
                }

                return { A: amplitude, B: frequency, C: phaseShift, D: verticalShift };
            };

            /**
             * Calculates the R-squared value for a trigonometric fit.
             */
            const calculateRSquaredTrig = (data, params) => {
                if (!params) return -Infinity;
                const yMean = data.reduce((sum, p) => sum + p.y, 0) / data.length;
                const predict = (x) => params.A * Math.sin(params.B * x + params.C) + params.D;
                const ssr = data.reduce((sum, p) => sum + Math.pow(p.y - predict(p.x), 2), 0);
                const sst = data.reduce((sum, p) => sum + Math.pow(p.y - yMean, 2), 0);
                return sst === 0 ? 1 : 1 - (ssr / sst);
            };

            /**
             * Performs reciprocal regression for functions of the form y = A/x
             */
            const reciprocalRegression = (data) => {
                let sumXY = 0;
                let validPoints = 0;
                data.forEach(p => {
                    if (Math.abs(p.x) > 1e-6) {
                        sumXY += p.x * p.y;
                        validPoints++;
                    }
                });
                if (validPoints < 5) return null;
                const A = sumXY / validPoints;
                return { A };
            };

            /**
             * Calculates R-squared for a reciprocal fit.
             */
            const calculateRSquaredReciprocal = (data, params) => {
                if (!params) return -Infinity;
                const yMean = data.reduce((sum, p) => sum + p.y, 0) / data.length;
                const predict = (x) => {
                    if (Math.abs(x) < 1e-6) return Infinity;
                    return params.A / x;
                };
                let ssr = 0, sst = 0, validPoints = 0;
                data.forEach(p => {
                    const predictedY = predict(p.x);
                    if (isFinite(predictedY)) {
                        ssr += Math.pow(p.y - predictedY, 2);
                        sst += Math.pow(p.y - yMean, 2);
                        validPoints++;
                    }
                });
                if (validPoints === 0 || sst === 0) return -Infinity;
                return 1 - (ssr / sst);
            };

            /**
             * Formats the trigonometric parameters into a readable string.
             */
            const formatTrigonometric = (params) => {
                if (!params) return null;
                let { A, B, C, D } = params;
                
                if (A < 0) {
                    A = -A;
                    C += Math.PI;
                }

                let result = '';
                if (Math.abs(A - 1) > 1e-2) {
                    result += A.toFixed(2) + '*';
                }

                let sinInner = '';
                if (Math.abs(B - 1) > 1e-2) {
                    sinInner += B.toFixed(2) + '*x';
                } else {
                    sinInner += 'x';
                }
                
                if (Math.abs(C) > 1e-2) {
                    sinInner += (C > 0 ? ' + ' : ' - ') + Math.abs(C).toFixed(2);
                }
                result += `sin(${sinInner})`;

                if (Math.abs(D) > 1e-2) {
                    result += (D > 0 ? ' + ' : ' - ') + Math.abs(D).toFixed(2);
                }

                return result;
            };

            /**
             * Formats the reciprocal parameters into a readable string.
             */
            const formatReciprocal = (params) => {
                if (!params) return null;
                return `${params.A.toFixed(2)} / x`;
            };

            /**
             * Formats the polynomial coefficients into a readable and evaluatable string.
             */
            const formatPolynomial = (coefficients) => {
                if (!coefficients || coefficients.length === 0) return '0.00';

                let parts = [];
                for (let i = coefficients.length - 1; i >= 0; i--) {
                    const c = coefficients[i];
                    if (Math.abs(c) < 1e-6) continue;

                    let term;
                    const absC = Math.abs(c);
                    const isCoeffOne = Math.abs(absC - 1) < 1e-6;

                    let valuePart = '';
                    if (isCoeffOne && i > 0) {
                        valuePart = '';
                    } else {
                        valuePart = absC.toFixed(2);
                    }

                    if (i > 0) {
                        if (valuePart !== '') valuePart += '*';
                        valuePart += 'x';
                        if (i > 1) valuePart += `^${i}`;
                    }
                    
                    if (valuePart === '') valuePart = 'x' + (i > 1 ? `^${i}` : '');

                    if (parts.length > 0) {
                        term = (c > 0) ? ` + ${valuePart}` : ` - ${valuePart}`;
                    } else {
                        if (c < 0) {
                             if (isCoeffOne && i > 0) {
                                term = `(-1)*${valuePart}`;
                             } else {
                                term = `-${valuePart}`;
                             }
                        } else {
                            term = valuePart;
                        }
                    }
                    parts.push(term);
                }

                if (parts.length === 0) return '0.00';
                return parts.join('').trim();
            };

            const analyzeGraph = () => {
                const allPoints = lines.flat().sort((a,b) => a.x - b.x);
                if (allPoints.length < 10) {
                    resultEl.innerHTML = `<span class="placeholder" style="color: #d9534f;">Please draw a more complete graph.</span>`;
                    return;
                }

                analyzeBtn.disabled = true;
                analyzeBtn.textContent = "Analyzing...";
                drawFuncBtn.disabled = true;
                
                analyzedFormula = null;
                formulaToDraw = null;
                redrawScene(); 

                resultEl.innerHTML = `<span class="placeholder">Calculating best fit...</span>`;
                
                setTimeout(() => {
                    try {
                        // --- Polynomial Analysis ---
                        let bestPolyFit = { degree: -1, rSquared: -Infinity, coefficients: null };
                        const maxDegree = Math.min(4, allPoints.length - 2);
                        for (let degree = 1; degree <= maxDegree; degree++) {
                            const coefficients = polynomialRegression(allPoints, degree);
                            if (!coefficients) continue;
                            const rSquared = calculateRSquared(allPoints, coefficients);
                            const adjustedRSquared = rSquared - (degree * 0.01);
                            if (adjustedRSquared > bestPolyFit.rSquared) {
                                bestPolyFit = { degree, rSquared, coefficients };
                            }
                        }

                        // --- Trigonometric Analysis ---
                        let bestTrigFit = { rSquared: -Infinity, params: null };
                        const trigParams = trigonometricRegression(allPoints);
                        if (trigParams) {
                            const trigRSquared = calculateRSquaredTrig(allPoints, trigParams);
                            bestTrigFit = { rSquared: trigRSquared, params: trigParams };
                        }
                        
                        // --- Reciprocal Analysis ---
                        let bestReciprocalFit = { rSquared: -Infinity, params: null };
                        // Heuristic: Reciprocal functions often have multiple disconnected lines.
                        if (lines.length > 1) { 
                            const reciprocalParams = reciprocalRegression(allPoints);
                            if (reciprocalParams) {
                                const reciprocalRSquared = calculateRSquaredReciprocal(allPoints, reciprocalParams);
                                // Give a slight boost to reciprocal fit if multiple lines are drawn, as it's a strong indicator.
                                bestReciprocalFit = { rSquared: reciprocalRSquared + 0.05, params: reciprocalParams }; 
                            }
                        }

                        // --- Compare and Select Best Fit ---
                        let formulaString;
                        let bestFitType = 'none';
                        let bestR2 = -Infinity;

                        if(bestPolyFit.rSquared > bestR2) {
                            bestR2 = bestPolyFit.rSquared;
                            bestFitType = 'polynomial';
                        }
                        if(bestTrigFit.rSquared > bestR2) {
                            bestR2 = bestTrigFit.rSquared;
                            bestFitType = 'trigonometric';
                        }
                        if(bestReciprocalFit.rSquared > bestR2) {
                            bestR2 = bestReciprocalFit.rSquared;
                            bestFitType = 'reciprocal';
                        }

                        console.log(`Poly R^2: ${bestPolyFit.rSquared.toFixed(4)}, Trig R^2: ${bestTrigFit.rSquared.toFixed(4)}, Reciprocal R^2: ${(bestReciprocalFit.rSquared - 0.05).toFixed(4)}`);
                        console.log(`Selected fit: ${bestFitType}`);

                        switch(bestFitType) {
                            case 'polynomial':
                                if (bestPolyFit.degree === -1 || !bestPolyFit.coefficients) {
                                    throw new Error("Could not find a suitable polynomial fit.");
                                }
                                formulaString = formatPolynomial(bestPolyFit.coefficients);
                                break;
                            case 'trigonometric':
                                if (!bestTrigFit.params) {
                                    throw new Error("Could not find a suitable trigonometric fit.");
                                }
                                formulaString = formatTrigonometric(bestTrigFit.params);
                                break;
                            case 'reciprocal':
                                if (!bestReciprocalFit.params) {
                                    throw new Error("Could not find a suitable reciprocal fit.");
                                }
                                formulaString = formatReciprocal(bestReciprocalFit.params);
                                break;
                            default:
                                throw new Error("No suitable function fit found.");
                        }

                        if (!formulaString) {
                            throw new Error("Could not format the resulting formula.");
                        }

                        analyzedFormula = formulaString;
                        functionInput.value = analyzedFormula;
                        resultEl.innerHTML = `f(x) &approx; <strong>${analyzedFormula}</strong>`;
                        drawFuncBtn.disabled = false;

                    } catch (error) {
                        console.error("Error analyzing graph:", error);
                        resultEl.innerHTML = `<span class="placeholder" style="color: #d9534f;">Could not analyze graph. See console for details.</span>`;
                    } finally {
                        analyzeBtn.disabled = false;
                        analyzeBtn.textContent = "Analyze";
                    }
                }, 50);
            };
            
            // --- Event Listeners Setup ---
            canvas.addEventListener('mousedown', startDrawing);
            canvas.addEventListener('mousemove', draw);
            canvas.addEventListener('mouseup', stopDrawing);
            canvas.addEventListener('mouseleave', stopDrawing);
            canvas.addEventListener('touchstart', startDrawing, { passive: false });
            canvas.addEventListener('touchmove', draw, { passive: false });
            canvas.addEventListener('touchend', stopDrawing);

            clearBtn.addEventListener('click', reset);
            analyzeBtn.addEventListener('click', analyzeGraph);
            
            drawFuncBtn.addEventListener('click', () => {
                const formula = functionInput.value.trim();
                if (!formula) return;
                formulaToDraw = formula;
                redrawScene();
            });

            functionInput.addEventListener('input', () => {
                drawFuncBtn.disabled = functionInput.value.trim() === '';
                if (formulaToDraw) {
                    formulaToDraw = null;
                    redrawScene();
                }
            });

            updateRangeBtn.addEventListener('click', redrawScene);

            // Initial Draw
            reset();
        });
    </script>
</body>
</html>
